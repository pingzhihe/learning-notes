import{_ as s,c as a,a as p,o as t}from"./app-DsOgR8nk.js";const e="/learning-notes/assets/str-1-lw1P8OLL.png",l="/learning-notes/assets/str-2-BOVP0Ovo.png",i={};function o(c,n){return t(),a("div",null,n[0]||(n[0]=[p(`<h1 id="所有权-ownership" tabindex="-1"><a class="header-anchor" href="#所有权-ownership"><span>所有权 ownership</span></a></h1><p>所有权是rust最独特的特性，可以让rust无需gc(garbage collecter)就能保证内存安全。</p><h3 id="stack-vs-heap" tabindex="-1"><a class="header-anchor" href="#stack-vs-heap"><span>Stack vs Heap</span></a></h3><p>Stack 和 Heap 都是可用的内存，但是结构差别很大</p><h2 id="所有权规则" tabindex="-1"><a class="header-anchor" href="#所有权规则"><span>所有权规则</span></a></h2><ul><li>每个值都有一个变量，这个变量是这个值改的所有者</li><li>每个值同时只能有一个所有者</li><li>当所有者离开作用域(scope), 这个值就会被删除。</li></ul><h2 id="变量作用域" tabindex="-1"><a class="header-anchor" href="#变量作用域"><span>变量作用域</span></a></h2><p>Scope 就是程序中一个项目的范围</p><h2 id="string-类型" tabindex="-1"><a class="header-anchor" href="#string-类型"><span>String 类型</span></a></h2><ul><li>String 比那些基础类型更复杂，因为它是一个复合类型</li><li>字符串字面值：不可变，硬编码到程序中</li></ul><p>我们可以使用from函数从字符串字面值创建出String 类型</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">let s = String::from(&quot;hello&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>&quot;::&quot; 表示from是String类型下的一个函数</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">&quot;, world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="内存与分配" tabindex="-1"><a class="header-anchor" href="#内存与分配"><span>内存与分配</span></a></h2><ul><li>字符串字面值，在编译的时候就知道内容了，其文本内容可以被硬编码到最终的可执行文件中，这也是为什么字符串字面值是快速的原因。（不可变性）</li><li>String 类型，为了支持其可变性，需要在heap上分配内存来保存编译文本时的未知的文本内容： <ul><li>操作系统必须在运行时来请求内存 <ul><li>这步通过调用 String::from 完成</li></ul></li><li>当用完String后，需要使用某种方式将内存返回给操作系统 <ul><li>这步，在拥有GC的语言中，由GC完成</li><li>没有GC，就需要我们去识别何时不再需要这些内存并调用代码来释放它。 <ul><li>如果忘了，那就浪费内存</li><li>如果过早释放，变量就会非法</li><li>如果重复释放，也会非法 Rust 采用了不同的方式；对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动地交还给操作系统。 这里是自动调用了drop函数。</li></ul></li></ul></li></ul></li><li>当变量离开作用域时, Rust 会自动调用drop函数, 并将变量使用的heap内存释放。</li></ul><h2 id="变量与数据交互的方式-移动-move" tabindex="-1"><a class="header-anchor" href="#变量与数据交互的方式-移动-move"><span>变量与数据交互的方式：移动(Move)</span></a></h2><p>多个变量可以与同一个数据使用一种独特的方式来交互</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> x <span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>整数是已知固定大小件简单的值，这两个5被压到了stack中</p><p>string类型，是一个三部分的值：指向存储在heap中的内容的指针，长度，容量</p><img src="`+e+`" alt="String" width="300"><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>当把s1赋给s2，String 的数据被复制了一份；</p><ul><li>在stack上复制了一份指针，长度，容量</li><li>并没有复制指针指向的heap上的数据</li></ul><img src="`+l+`" alt="String" width="300"><p>当s1,s2离开作用域时，它们都会尝试释放同一块内存。这会导致一个双重释放的错误，这是非常危险的。 double free bug！ 为了保证内存安全：</p><ul><li>Rust 没有尝试复制被分配的内存</li><li>Rust 让s1失效。 <ul><li>当s1离开作用域时，rust不需要释放任何东西。</li></ul></li></ul><p>这里会报错，因为s1已经失效了，rust不允许使用失效的变量。</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span></span>
<span class="line"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}, world!&quot;</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Rust 让s1失效的操作叫做：移动(move)。 Rust不会自动创建数据的深拷贝 修复方法：</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{},{}&quot;</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对heap上的数据进行深度拷贝（消耗资源）</p><h3 id="stack上的数据-复制" tabindex="-1"><a class="header-anchor" href="#stack上的数据-复制"><span>Stack上的数据：复制</span></a></h3><p>Copy trait, 可以用于像整数这样可以完全存放在stack上的类型。<br> 如果一个类型实现了Copy这个trait, 那么旧的变量在赋值以后仍然可用。<br> 如何一个类型或者该类型的一部分实现了Drop trait 那么Rust 就不允许实现Copy trait。</p><h3 id="一些拥有copy-trait的类型" tabindex="-1"><a class="header-anchor" href="#一些拥有copy-trait的类型"><span>一些拥有Copy trait的类型</span></a></h3><p>任何单标量的组合类型都可以是Copy的。<br> 如果需要分配内存或者某种资源的都不是Copy的。</p><ul><li>一些拥有Copy trait 的类型： <ul><li>所有的整数类型, eg: u32</li><li>bool</li><li>char</li><li>所有的浮点数类型, eg: f64</li><li>Tuple (元组), 如果其元素类型都是Copy的，那么该元组也是Copy的。 <ul><li>(i32, i32) 是。</li><li>(i32, String) 不是。</li></ul></li></ul></li></ul><h2 id="所有权和函数" tabindex="-1"><a class="header-anchor" href="#所有权和函数"><span>所有权和函数</span></a></h2><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">take_ownership</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 从这以后，s不再有效</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token function">make_copy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 从这以后，x还可以继续使用。</span></span>
<span class="line">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">take_ownership</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> some_string<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">make_copy</span><span class="token punctuation">(</span>some_integer<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> some_integer<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="返回值与作用域" tabindex="-1"><a class="header-anchor" href="#返回值与作用域"><span>返回值与作用域</span></a></h2><p>函数在返回值的过程中也会同样发生所有权的转移 一个变量的所有权总是遵循相同的模式：</p><ul><li>将值赋给另一个变量时会发生移动</li><li>当一个包含heap的数据的变量离开作用域时, 它的值会被drop函数清理,除非数据的所有权移动到另外一个变量上了</li></ul><p><strong>如何让函数使用某个值,但不获得其所有权？</strong></p><h2 id="引用与借用" tabindex="-1"><a class="header-anchor" href="#引用与借用"><span>引用与借用</span></a></h2><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The length of &#39;{}&#39; is {}.&quot;</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">usize</span> <span class="token punctuation">{</span></span>
<span class="line">    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">\`\`\`rust</span>
<span class="line">这里参数的类型是<span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">,</span> 称为引用<span class="token punctuation">(</span>reference<span class="token punctuation">)</span>。  </span>
<span class="line"><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">&quot;./images/ref.png&quot;</span> alt<span class="token operator">=</span><span class="token string">&quot;String&quot;</span> width<span class="token operator">=</span><span class="token string">&quot;300&quot;</span><span class="token operator">&gt;</span>  </span>
<span class="line">这里s就是s1的引用。</span>
<span class="line"></span>
<span class="line">我们把引用作为函数参数叫做借用<span class="token punctuation">(</span>borrowing<span class="token punctuation">)</span>。</span>
<span class="line">和变量一样<span class="token punctuation">,</span>引用默认是不可变的。  </span>
<span class="line">## 可变引用</span>
<span class="line">\`\`\`rust</span>
<span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token keyword">mut</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The length of &#39;{}&#39; is {}.&quot;</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">usize</span> <span class="token punctuation">{</span></span>
<span class="line">    s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">&quot;, world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可变引用有一个重要的限制：在特定作用域内,对于某一块数据,只能有<strong>一个</strong>可变的引用。 这里就会报错</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span></span>
<span class="line">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}, {}&quot;</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的好处是可以在编译的时候防止数据竞争</p><ul><li>以下三种行为会发生数据竞争： <ul><li>两个或多个指针同时访问同一个数据</li><li>至少有一个指针被用来写入数据</li><li>没有使用任何机制来同步对数据的访问</li></ul></li><li>可以通过创建新的作用域来允许非同时地创建多个可变引用</li></ul><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>引用的规则：</p><ul><li>在任意给定的时刻，只能满足下列条件之一： <ul><li>一个可变引用</li><li>任意数量不可变的引用</li></ul></li><li>引用必须一直有效</li></ul>`,53)]))}const r=s(i,[["render",o],["__file","Ownership.html.vue"]]),d=JSON.parse('{"path":"/rust-learning/Ownership.html","title":"所有权 ownership","lang":"en-US","frontmatter":{},"headers":[{"level":3,"title":"Stack vs Heap","slug":"stack-vs-heap","link":"#stack-vs-heap","children":[]},{"level":2,"title":"所有权规则","slug":"所有权规则","link":"#所有权规则","children":[]},{"level":2,"title":"变量作用域","slug":"变量作用域","link":"#变量作用域","children":[]},{"level":2,"title":"String 类型","slug":"string-类型","link":"#string-类型","children":[]},{"level":2,"title":"内存与分配","slug":"内存与分配","link":"#内存与分配","children":[]},{"level":2,"title":"变量与数据交互的方式：移动(Move)","slug":"变量与数据交互的方式-移动-move","link":"#变量与数据交互的方式-移动-move","children":[{"level":3,"title":"Stack上的数据：复制","slug":"stack上的数据-复制","link":"#stack上的数据-复制","children":[]},{"level":3,"title":"一些拥有Copy trait的类型","slug":"一些拥有copy-trait的类型","link":"#一些拥有copy-trait的类型","children":[]}]},{"level":2,"title":"所有权和函数","slug":"所有权和函数","link":"#所有权和函数","children":[]},{"level":2,"title":"返回值与作用域","slug":"返回值与作用域","link":"#返回值与作用域","children":[]},{"level":2,"title":"引用与借用","slug":"引用与借用","link":"#引用与借用","children":[]}],"git":{"updatedTime":1731216681000,"contributors":[{"name":"pingzhihe","email":"pzh1760473545@gmail.com","commits":2,"url":"https://github.com/pingzhihe"}]},"filePathRelative":"rust-learning/Ownership.md"}');export{r as comp,d as data};
